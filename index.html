<html>
	<head>
		<title>Mycom Test</title>
    	<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no" />
    	<meta charset="UTF-8">
		<style>
			html {
				width: 100%;
				height: 100%;
				margin: 0;
				padding: 0;
			}
			body { 
				width: 100%;
				height: 100%;
				margin: 0;
				padding: 0;
				border: 0;
				text-align: center;
				margin-left: auto;
				margin-right: auto; 
			}
			#console {
				margin-left: auto;
				margin-right: auto;
				border: 0;
				padding: 0;
			}
			header{

			}
		</style>
	</head>
	<body>
		<div id = "gyro">	
		</div>
		<script src="three.js"></script>
		<script>

			var pi = 3.141592;
			var f = 0;
			
			var fps;
			
			const canvas = document.createElement("canvas");
			let gl;

			var controls;
			var resGyro=false;
			
			//ジャイロの使用許可
			function RequestGyroSensor()
			{
				DeviceOrientationEvent.requestPermission().then(function(responce){
					if(responce === 'granted')
					{
						window.addEventListener("deviceorientation", deviceOrientation);
					}
				}).catch(function(e){
					console.log(e);
				});
			}

			if(window.DeviceOrientationEvent)
			{
				if(DeviceOrientationEvent.requestPermission && typeof DeviceOrientationEvent.requestPermission === 'function')
				{
					//var banner = '<div  style="z-index: 1; position: absolute; width: 100%; background-color: rgb(0, 0, 0);" onclick="RequestGyroSensor();" id="sensorrequest"><p style="color: rgb(0, 0, 255);">センサーの有効化</p></div>';
					var target = document.getElementById("gyro");
					var p = document.createElement("p");
					p.style.color = "blue";
					p.innerText = "センサーの有効化";

					target.style.zIndex = "1px";
					target.style.position = "absolute";
					target.style.width = "100%";
					target.style.backgroundColor = "white";
					target.onclick = RequestGyroSensor();

					target.appendChild(p);
				}
				else
				{
					window.addEventListener("deviceorientation", deviceOrientation);
				}
			}

			//console.log();

			function deviceOrientation(e)
			{
				//e.preventDefault();

				var dir = e.alpha;
				var fb = e.beta;
				var lr = e.gamma;
			}

			try {
  				gl = canvas.getContext("experimental-webgl");
 				//ドライバー情報を取得
 				const ext = gl.getExtension("WEBGL_debug_renderer_info");

 				if (!ext) {
 				   renderer = "";
				} else {
 				   renderer = gl.getParameter(ext.UNMASKED_RENDERER_WEBGL);
 				}
			} catch (e) {
  			// WebGL未対応の場合
  				gl = null;
  				renderer = "";
			}
			
			var result = (renderer.match(/GeForce/) != null) || (renderer.match(/Radeon/) != null);

			if(result)
			{
				fps = 1 / 60;
			}
			else
			{
				fps = 1 / 30;
			}

			/* renderer(レンダラー)の作成　*/
			var renderer = new THREE.WebGLRenderer();
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.domElement.id = 'console';
			renderer.domElement.style.zIndex = 0;
			document.body.appendChild( renderer.domElement);

			/* scene(シーン)の作成 */
			var scene = new THREE.Scene();

			/* camera(カメラ)の作成 */
			var camera = new THREE.PerspectiveCamera( 45, window.innerWidth/window.innerHeight, 1, 10000 );
			
			/* object(オブジェクト)の作成 */
			var geometry = new THREE.BoxGeometry( 100, 100, 100);
			const material = new THREE.MeshStandardMaterial( { color: 0x00ff00 } );
			var cube = new THREE.Mesh( geometry, material );
			scene.add( cube );

			var geometry2 = new THREE.BoxGeometry(1000, 1, 1000);
			const material2 = new THREE.MeshStandardMaterial( { color: 0xffffff } );
			var cube2 = new THREE.Mesh( geometry2, material2 );
			scene.add( cube2 );

			cube2.position.y = - 100;

			var geometry3 = new THREE.SphereGeometry(60 , 36, 36);
			var material3 = new THREE.MeshStandardMaterial({color: 0x00f0ff});
			var sphere = new THREE.Mesh(geometry3, material3);
			scene.add(sphere);
			sphere.position.x = 200;
			sphere.position.z = -200;

			const geo = new THREE.CylinderGeometry(200, 200, 700, 32 );
			const mate = new THREE.MeshStandardMaterial( {color: 0xf0f0f0} );
			const cyl = new THREE.Mesh( geo, mate );
			scene.add( cyl );

			cyl.position.x = 700;
			cyl.position.z = - 1000;
			cyl.position.y = 200;

			const geo2 = new THREE.TorusGeometry( 100, 20, 32, 100 );
			const mate2 = new THREE.MeshStandardMaterial( { color: 0xffff00 } , metalness = 1.0);
			const torus = new THREE.Mesh( geo2, mate2 );
			scene.add( torus );

			torus.position.y = 100;
			torus.position.z = - 100;
			torus.position.x = -300;
			
			/* camera(カメラ)の位置設定　*/
			camera.position.y = 20 * camera.aspect;
			camera.position.z = 400 * camera.aspect;
			camera.rotation.x = - Math.atan(camera.position.y / camera.position.z);

			/*
			import { Sky } from './Sky.js';
	 
			//Sky
			const sky = new Sky();
			sky.scale.setScalar(450000);
			scene.add(sky);
			 
			//Skyの設定
			const sky_uniforms = sky.material.uniforms;
			sky_uniforms['turbidity'].value = 10;
			sky_uniforms['rayleigh'].value = 2;
			sky_uniforms['luminance'].value = 1;
			sky_uniforms['mieCoefficient'].value = 0.005;
			sky_uniforms['mieDirectionalG'].value = 0.8;
			 
			//Sun
			const sunSphere = new THREE.Mesh(
			    new THREE.SphereBufferGeometry(200,16,8),
			    new THREE.MeshBasicMaterial({color:0xFFFFFF})
			);
			scene.add(sunSphere);
			 
			//Sunの設定
			const sun_uniforms = sky.material.uniforms;
			sun_uniforms['turbidity'].value = 10;
			sun_uniforms['rayleigh'].value = 2;
			sun_uniforms['mieCoefficient'].value = 0.005;
			sun_uniforms['mieDirectionalG'].value = 0.8;
			sun_uniforms['luminance'].value = 1;
			 
			const theta = Math.PI * ( -0.01 );
			const phi = 2 * Math.PI * ( -0.25 );
			const distance = 400000;
			sunSphere.position.x = distance * Math.cos(phi);
			sunSphere.position.y = distance * Math.sin(phi) * Math.sin(theta);
			sunSphere.position.z = distance * Math.sin(phi) * Math.cos(theta);
			sunSphere.visible = true;
			sun_uniforms['sunPosition'].value.copy(sunSphere.position);
			*/

			// 平行光源
  			const light = new THREE.DirectionalLight(0xffffff, 2);
  			light.intensity = 2; // 光の強さを倍に
			light.position.set(1, 1, 1);
			light.castShadow = true;
 			// シーンに追加
 			scene.add(light);

			var light2 = new THREE.AmbientLight(0x333333);
			scene.add(light2);

			window.addEventListener('resize', function () {
				renderer.setPixelRatio(window.devicePixelRatio);
                renderer.setSize(window.innerWidth, window.innerHeight );
				camera.aspect = window.innerWidth / innerHeight;
				camera.updateProjectionMatrix();
            }, false);

			var mouseX, mouseY;
			var onmouse = 0;
			var vecx = 0;
			var vecy = 0;
			var lt = 1;
			var accx = 0;
			var accy = 0;
			var disx = - camera.rotation.x;
			var disy = - camera.rotation.y;

			window.onmousemove = function(e) {
				if(e)
				{
					mouseX = e.pageX;
					mouseY = e.pageY;
				}
				else 
				{
     				mouseX = event.pageX + document.body.scrollLeft;
     				mouseY = event.pageY + document.body.scrollTop;
    			}

				onmouse = 1;
			};

			window.onmouseout = function(e) {
				lt = 1;
				onmouse = 0;
				accx = 0;
				accy = 0;
				vecx = (vecx - camera.rotation.x);
				vecy = (vecy - camera.rotation.y);
			};

			var time = 0;
			var timeRatio = 0;

			function updateTimeRatio()
			{
				const lastTime = time;
				if(lastTime > 0)
				{
					const fps60 = 1000 / 60;
					const dTime = new Date().getTime() - lastTime;
					timeRatio = dTime / fps60 / 60;
				}

				time = new Date().getTime();
			}

			function testf()
			{
				sphere.position.y = 100 * Math.sin(f * pi);
				torus.rotation.y += fps;

				//console.log(torus.rotation.z);
			}

			function testphi()
			{

			}

			/* 繰り返しの処理　*/
			var animate = function () {

				f += fps;
				
				//cube.position.x = 100 * Math.sin(f * pi);
				//cube.position.y = 100 * Math.cos(f * pi);
				testf();

				cube.rotation.x += fps;
				cube.rotation.y += fps;

				var y = 90 * (1 / camera.aspect) * 0.5;
				var z = 200 * camera.aspect;

				var dy = camera.position.y - y;
				var dz = camera.position.z - z;

				if(dy != 0)
				{
					camera.position.y -= fps * dy * 1.9;
				}

				if(dz != 0)
				{
					camera.position.z -= fps * dz;
				}

				if(camera.position.z < 550)
				{
					camera.position.z = 550;
				}

				if(camera.position.z > 800)
				{
					camera.position.z = 800;
				}

				//console.log(camera.position.y, camera.position.z);

				var centerpoint = [window.innerWidth / 2, window.innerHeight / 2];

				if(onmouse)
				{
					var ry = - Math.atan((centerpoint[0] - mouseX) / camera.position.z) * 0.08;
					var rx = - Math.atan((centerpoint[1] - mouseY) / camera.position.z) * 0.08;

					var drx = camera.rotation.x - rx;
					var dry = camera.rotation.y - ry;

					if(camera.rotation.x <= 2 && camera.rotation.x >= -2)
					{
						if(drx != 0)
						{
							camera.rotation.x -= fps * drx;
						}
					}

					if(camera.rotation.y <= 2 && camera.rotation.y >= -2)
					{
						if(dry != 0)
						{
							camera.rotation.y -= fps * dry;
						}
					}
				}
				else
				{
					if(lt > 0)
					{
						disx = - camera.rotation.x;
						disy = - camera.rotation.y;
						accx = (disx - vecx * lt) * 2 / lt * lt;
						vecx += accx * timeRatio;
						accy = (disy - vecy * lt) * 2 / lt * lt;
						vecy += accy * timeRatio;
						lt -= timeRatio;

						camera.rotation.x += vecx * timeRatio;
						camera.rotation.y += vecy * timeRatio;
					}
				}

				renderer.clear();
				/*
				if(isGyro)
				{
					controls.update();
				}*/
				renderer.render( scene, camera );

				//console.log(timeRatio);

				requestAnimationFrame( animate );
				updateTimeRatio();
			};
			animate();
			
		</script>
	</body>
</html>
